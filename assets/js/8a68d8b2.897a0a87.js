"use strict";(self.webpackChunkboehs_com=self.webpackChunkboehs_com||[]).push([[12],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>y});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=r,y=u["".concat(o,".").concat(h)]||u[h]||m[h]||s;return n?a.createElement(y,i(i({ref:t},p),{},{components:n})):a.createElement(y,i({ref:t},p))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<s;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4138:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const s={},i="Parsing null terminated key/value ASCII strings in Ruby",l={permalink:"/blog/2014/10/31/parsing-null-terminated-key-value-ascii-strings-in-ruby.html",source:"@site/blog/2014-10-31-parsing-null-terminated-key-value-ascii-strings-in-ruby.html.md",title:"Parsing null terminated key/value ASCII strings in Ruby",description:"I've recently been messing with a lot of hex thanks to my current client. I ran across a key/value hex string where each key/value pair was NULL terminated (pairs separated from other pairs with a NULL character) and each key was seperated from its value by a colon. Here's the hex string:",date:"2014-10-31T00:00:00.000Z",formattedDate:"October 31, 2014",tags:[],readingTime:1.915,hasTruncateMarker:!0,authors:[],frontMatter:{},prevItem:{title:"Configuring Pow including SSL",permalink:"/blog/2015/01/20/configuring-pow-including-ssl.html"},nextItem:{title:"Test if memcache is running and accessible",permalink:"/blog/2014/02/03/test-if-memcache-is-running-and-accessible.html"}},o={authorsImageUrls:[]},c=[],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"I've recently been messing with a lot of hex thanks to my current client. I ran across a key/value hex string where each key/value pair was NULL terminated (pairs separated from other pairs with a NULL character) and each key was seperated from its value by a colon. Here's the hex string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},'>> hexstr = "56494e3a3147314a433534343452373235323336370050524f544f3a3500504152414d533a302c312c322c342c372c392c31312c31342c323000494e44435452533a302830303030303030303030303131292c3128303131303031303131313129"\n')),(0,r.kt)("p",null,"First I wanted to convert this to ASCII, Ruby makes this fairly simple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},">> str = [hexstr].pack 'H*'\n=> \"VIN:1G1JC5444R7252367\\x00PROTO:5\\x00PARAMS:0,1,2,4,7,9,11,14,20\\x00INDCTRS:0(0000000000011),1(01100101111)\"\n")),(0,r.kt)("p",null,"Now we have an ascii string with null terminators. Ruby has escape sequences like ",(0,r.kt)("inlineCode",{parentName:"p"},"\\n")," for newline and ",(0,r.kt)("inlineCode",{parentName:"p"},"\\t")," for tab. It also has hex escape sequences, for example the letter ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"\\x61")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"61")," is its hex value. A null character is the hex value ",(0,r.kt)("inlineCode",{parentName:"p"},"00")," so the escape sequence is ",(0,r.kt)("inlineCode",{parentName:"p"},"\\x00"),". Now to break the string apart we use split:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},'>> kv_pairs = str.split "\\x00"\n=> ["VIN:1G1JC5444R7252367", "PROTO:5", "PARAMS:0,1,2,4,7,9,11,14,20", "INDCTRS:0(0000000000011),1(01100101111)"]\n')),(0,r.kt)("p",null,"Finally, you can split these pairs into further pairs by mapping over them with split and then use Ruby's ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash[]")," syntax to create a hash from the array of arrays:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},'>> kv_pairs_array = kv_pairs.map { |key_vals| key_vals.split \':\' }\n=> [["VIN", "1G1JC5444R7252367"], ["PROTO", "5"], ["PARAMS", "0,1,2,4,7,9,11,14,20"], ["INDCTRS", "0(0000000000011),1(01100101111)"]]\nobdii_info = Hash[kv_pairs_array]\n=> {"VIN"=>"1G1JC5444R7252367", "PROTO"=>"5", "PARAMS"=>"0,1,2,4,7,9,11,14,20", "INDCTRS"=>"0(0000000000011),1(01100101111)"}\n')),(0,r.kt)("p",null,"If you're like me and don't like upcased strings for keys, you can symbolize the keys (thanks active support) with this oneliner (I added the downcase call to the mix):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},'>> obdii_info = Hash[obdii_info.map { |(k, v)| [ k.downcase.to_sym, v ] }]\n=> {:vin=>"1G1JC5444R7252367", :proto=>"5", :params=>"0,1,2,4,7,9,11,14,20", :indctrs=>"0(0000000000011),1(01100101111)"}\n')),(0,r.kt)("p",null,"Looking nice! I've made these into methods for a util class I include. Eventually I'd like to make a special hex string class to handle this better, but for my current use case this works well."),(0,r.kt)("p",null,"Here are some methods you can throw in your own class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"def hex_to_ascii hex_string\n  [hex_string.delete ' '].pack 'H*'\nend\n\ndef hashify_null_term_str str\n  Hash[str.split(\"\\x00\").map { |key_vals| key_vals.split ':' }]\nend\n\ndef symbolize_keys hash\n  Hash[hash.map { |(k, v)| [ k.downcase.to_sym, v ] }]\nend\n\n# Example usage:\nsymbolize_keys hashify_null_term_str hex_to_ascii \"56 49 4e 3a 00 50 52 4f 54 4f 3a 30 00 50 41 52 41 4d 53 3a\"\n# => { vin: nil, proto: \"0\", params: nil }\n")),(0,r.kt)("p",null,"Happy Hacking."))}m.isMDXComponent=!0}}]);